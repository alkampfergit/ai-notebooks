#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp"},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

### References

- [Azure Ai Resources https://ai.azure.com/explore/aiservices?tid=854d7cc7-3d8e-42db-b62b-39ff06ca250f](https://ai.azure.com/explore/aiservices?tid=854d7cc7-3d8e-42db-b62b-39ff06ca250f)

#!csharp

#r "nuget: Azure.AI.DocumentIntelligence, *"
#r "nuget: UglyToad.PdfPig, *"

#!import ../dotenv.cs

#!csharp

using Azure;
using Azure.AI.DocumentIntelligence;
using System.IO;

string endpoint = Dotenv.Get("AZURE_DI_ENDPOINT");
string key = Dotenv.Get("AZURE_DI_KEY");
var credential = new AzureKeyCredential(key);
var client = new DocumentIntelligenceClient(new Uri(endpoint), credential);


// Load binary file
string filePath = "C:\\temp\\manualedreame2.pdf";
//string filePath = @"C:\temp\sampleocr1.jpeg";
var data = File.ReadAllBytes(filePath);

var binaryData = new BinaryData(data);
AnalyzeDocumentOptions content = new AnalyzeDocumentOptions("prebuilt-layout", binaryData);
content.OutputContentFormat = DocumentContentFormat.Markdown;

Operation<AnalyzeResult> operation = await client.AnalyzeDocumentAsync(WaitUntil.Completed, content);

AnalyzeResult result = operation.Value;

#!csharp

// now start writing the result on a subdirectory 
var outputDirectory = Path.Combine(Environment.CurrentDirectory, "azure-di-output");
if (!Directory.Exists(outputDirectory))
{
    Directory.CreateDirectory(outputDirectory);
}
// Append original file name to result file
var originalFileName = Path.GetFileNameWithoutExtension(filePath);
var outputFilePath = Path.Combine(outputDirectory, $"result_{originalFileName}.md");
File.WriteAllText(outputFilePath, result.Content, System.Text.Encoding.UTF8);

#!csharp

// Delete existing table files for this document before generating new ones
var tableFilePattern = $"table_*_{originalFileName}.md";
var existingTableFiles = Directory.GetFiles(outputDirectory, tableFilePattern);
foreach (var file in existingTableFiles)
{
    File.Delete(file);
    Console.WriteLine($"Deleted existing file: {Path.GetFileName(file)}");
}

// Now dump table information and save each table to a separate file
int tableIndex = 0;
foreach (var table in result.Tables)
{
    tableIndex++;
    int pageNumber = table.BoundingRegions[0].PageNumber;
    
    Console.WriteLine($"Table {tableIndex} in page {pageNumber} has {table.RowCount} rows and {table.ColumnCount} columns.");

    // Build markdown table
    var sb = new System.Text.StringBuilder();
    sb.AppendLine($"# Table {tableIndex} - Page {pageNumber}");
    
    if (!string.IsNullOrEmpty(table.Caption?.Content))
    {
        sb.AppendLine($"**Caption:** {table.Caption.Content}");
    }
    sb.AppendLine($"**Rows:** {table.RowCount}, **Columns:** {table.ColumnCount}");
    sb.AppendLine();
    

    // Create a 2D array to hold all cell contents
    string[,] tableData = new string[table.RowCount, table.ColumnCount];
    
    // Fill the array with cell contents
    foreach (var cell in table.Cells)
    {
        string content = cell.Content?.Trim() ?? "";
        // Escape markdown characters and handle line breaks
        content = content.Replace("|", "\\|").Replace("\n", " ").Replace("\r", "");
        tableData[cell.RowIndex, cell.ColumnIndex] = content;
    }

    // Generate markdown table
    for (int row = 0; row < table.RowCount; row++)
    {
        var rowCells = new string[table.ColumnCount];
        for (int col = 0; col < table.ColumnCount; col++)
        {
            rowCells[col] = tableData[row, col] ?? "";
        }
        
        sb.AppendLine("| " + string.Join(" | ", rowCells) + " |");
        
        // Add separator after header row
        if (row == 0)
        {
            sb.AppendLine("|" + string.Concat(Enumerable.Repeat(" --- |", table.ColumnCount)));
        }
    }

    // Save table to file
    var tableFileName = $"table_{tableIndex:D2}_page{pageNumber}_{originalFileName}.md";
    var tableFilePath = Path.Combine(outputDirectory, tableFileName);
    File.WriteAllText(tableFilePath, sb.ToString(), System.Text.Encoding.UTF8);
    
    Console.WriteLine($"Table saved to: {tableFileName}");
    Console.WriteLine("------------------------------");
}

Console.WriteLine($"Total tables processed: {tableIndex}");

#!csharp

// Process the markdown file to convert <figure> tags to markdown images
var markdownFilePath = Path.Combine(outputDirectory, $"result_{originalFileName}.md");
var processedFilePath = Path.Combine(outputDirectory, $"processed_{originalFileName}.md");

// Create images subdirectory
var imagesDirectory = Path.Combine(outputDirectory, "images");
if (!Directory.Exists(imagesDirectory))
{
    Directory.CreateDirectory(imagesDirectory);
    Console.WriteLine($"Created images directory: {imagesDirectory}");
}

// Read the markdown content
string markdownContent = File.ReadAllText(markdownFilePath, System.Text.Encoding.UTF8);

// Process figure tags
var figurePattern = @"<figure>(.*?)</figure>";
var regex = new System.Text.RegularExpressions.Regex(figurePattern, 
    System.Text.RegularExpressions.RegexOptions.Singleline | 
    System.Text.RegularExpressions.RegexOptions.IgnoreCase);

int figureCount = 0;
string processedContent = regex.Replace(markdownContent, match => {
    figureCount++;
    return $"![Figure {figureCount}](images/figure{figureCount}.png)";
});

// Save the processed markdown
File.WriteAllText(processedFilePath, processedContent, System.Text.Encoding.UTF8);

Console.WriteLine($"Processed markdown saved to: processed_{originalFileName}.md");
Console.WriteLine($"Total figures converted: {figureCount}");
Console.WriteLine($"Images should be placed in: {Path.GetRelativePath(outputDirectory, imagesDirectory)}");

#!csharp

using UglyToad.PdfPig;
using UglyToad.PdfPig.Content;

// Only process if the original file is a PDF
if (Path.GetExtension(filePath).ToLowerInvariant() == ".pdf")
{
    Console.WriteLine("PDF file detected. Extracting images...");
    
    // Create images subdirectory if it doesn't exist
    var imagesDirectory = Path.Combine(outputDirectory, "images");
    if (!Directory.Exists(imagesDirectory))
    {
        Directory.CreateDirectory(imagesDirectory);
    }
    
    // Delete existing images with the same prefix
    var imagePrefix = $"{originalFileName}_";
    var existingImages = Directory.GetFiles(imagesDirectory, $"{imagePrefix}*");
    foreach (var imageFile in existingImages)
    {
        File.Delete(imageFile);
        Console.WriteLine($"Deleted existing image: {Path.GetFileName(imageFile)}");
    }
    
    // Extract images from PDF
    using (PdfDocument document = PdfDocument.Open(filePath))
    {
        int imageCount = 0;
        
        for (int pageNum = 1; pageNum <= document.NumberOfPages; pageNum++)
        {
            Page page = document.GetPage(pageNum);
            
            foreach (var image in page.GetImages())
            {
                imageCount++;
                try
                {
                    // Get image bytes
                    var imageBytes = image.RawBytes.ToArray();
                    
                    // Determine file extension based on image format
                    string extension = ".png"; // default
                    if (image.ColorSpace?.Name?.Contains("JPEG") == true || 
                        image.Filter?.Contains("DCTDecode") == true)
                    {
                        extension = ".jpg";
                    }
                    
                    // Save image with proper naming convention
                    var imageFileName = $"{originalFileName}_figure{imageCount}{extension}";
                    var imageFilePath = Path.Combine(imagesDirectory, imageFileName);
                    
                    File.WriteAllBytes(imageFilePath, imageBytes);
                    Console.WriteLine($"Extracted image {imageCount}: {imageFileName}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Failed to extract image {imageCount}: {ex.Message}");
                }
            }
        }
        
        Console.WriteLine($"Total images extracted: {imageCount}");
    }
}
else
{
    Console.WriteLine($"File is not a PDF ({Path.GetExtension(filePath)}). Skipping image extraction.");
}
