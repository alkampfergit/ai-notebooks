#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp"},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

### References

- [Azure Ai Resources https://ai.azure.com/explore/aiservices?tid=854d7cc7-3d8e-42db-b62b-39ff06ca250f](https://ai.azure.com/explore/aiservices?tid=854d7cc7-3d8e-42db-b62b-39ff06ca250f)

#!csharp

#r "nuget: Azure.AI.DocumentIntelligence, *"
#r "nuget: PdfPig, *"
#r "nuget: PdfPig.Rendering.Skia"
#r "nuget: System.Drawing.Common"

#!import ../dotenv.cs

#!csharp

using Azure;
using Azure.AI.DocumentIntelligence;
using System.IO;

string endpoint = Dotenv.Get("AZURE_DI_ENDPOINT");
string key = Dotenv.Get("AZURE_DI_KEY");
var credential = new AzureKeyCredential(key);
var client = new DocumentIntelligenceClient(new Uri(endpoint), credential);


// Load binary file
string filePath = "C:\\temp\\manualedreame2.pdf";
//string filePath = @"C:\temp\sampleocr1.jpeg";
var data = File.ReadAllBytes(filePath);

var binaryData = new BinaryData(data);
AnalyzeDocumentOptions content = new AnalyzeDocumentOptions("prebuilt-layout", binaryData);
content.OutputContentFormat = DocumentContentFormat.Markdown;

Operation<AnalyzeResult> operation = await client.AnalyzeDocumentAsync(WaitUntil.Completed, content);

AnalyzeResult result = operation.Value;

#!csharp

// now start writing the result on a subdirectory 
var outputDirectory = Path.Combine(Environment.CurrentDirectory, "azure-di-output");
if (!Directory.Exists(outputDirectory))
{
    Directory.CreateDirectory(outputDirectory);
}
// Append original file name to result file
var originalFileName = Path.GetFileNameWithoutExtension(filePath);
var outputFilePath = Path.Combine(outputDirectory, $"result_{originalFileName}.md");
File.WriteAllText(outputFilePath, result.Content, System.Text.Encoding.UTF8);

#!csharp

// Delete existing table files for this document before generating new ones
var tableFilePattern = $"table_*_{originalFileName}.md";
var existingTableFiles = Directory.GetFiles(outputDirectory, tableFilePattern);
foreach (var file in existingTableFiles)
{
    File.Delete(file);
    Console.WriteLine($"Deleted existing file: {Path.GetFileName(file)}");
}

// Now dump table information and save each table to a separate file
int tableIndex = 0;
foreach (var table in result.Tables)
{
    tableIndex++;
    int pageNumber = table.BoundingRegions[0].PageNumber;
    
    Console.WriteLine($"Table {tableIndex} in page {pageNumber} has {table.RowCount} rows and {table.ColumnCount} columns.");

    // Build markdown table
    var sb = new System.Text.StringBuilder();
    sb.AppendLine($"# Table {tableIndex} - Page {pageNumber}");
    
    if (!string.IsNullOrEmpty(table.Caption?.Content))
    {
        sb.AppendLine($"**Caption:** {table.Caption.Content}");
    }
    sb.AppendLine($"**Rows:** {table.RowCount}, **Columns:** {table.ColumnCount}");
    sb.AppendLine();
    

    // Create a 2D array to hold all cell contents
    string[,] tableData = new string[table.RowCount, table.ColumnCount];
    
    // Fill the array with cell contents
    foreach (var cell in table.Cells)
    {
        string content = cell.Content?.Trim() ?? "";
        // Escape markdown characters and handle line breaks
        content = content.Replace("|", "\\|").Replace("\n", " ").Replace("\r", "");
        tableData[cell.RowIndex, cell.ColumnIndex] = content;
    }

    // Generate markdown table
    for (int row = 0; row < table.RowCount; row++)
    {
        var rowCells = new string[table.ColumnCount];
        for (int col = 0; col < table.ColumnCount; col++)
        {
            rowCells[col] = tableData[row, col] ?? "";
        }
        
        sb.AppendLine("| " + string.Join(" | ", rowCells) + " |");
        
        // Add separator after header row
        if (row == 0)
        {
            sb.AppendLine("|" + string.Concat(Enumerable.Repeat(" --- |", table.ColumnCount)));
        }
    }

    // Save table to file
    var tableFileName = $"table_{tableIndex:D2}_page{pageNumber}_{originalFileName}.md";
    var tableFilePath = Path.Combine(outputDirectory, tableFileName);
    File.WriteAllText(tableFilePath, sb.ToString(), System.Text.Encoding.UTF8);
    
    Console.WriteLine($"Table saved to: {tableFileName}");
    Console.WriteLine("------------------------------");
}

Console.WriteLine($"Total tables processed: {tableIndex}");

#!csharp

// Process the markdown file to convert <figure> tags to markdown images
var markdownFilePath = Path.Combine(outputDirectory, $"result_{originalFileName}.md");
var processedFilePath = Path.Combine(outputDirectory, $"processed_{originalFileName}.md");

// Create images subdirectory
var imagesDirectory = Path.Combine(outputDirectory, "images");
if (!Directory.Exists(imagesDirectory))
{
    Directory.CreateDirectory(imagesDirectory);
    Console.WriteLine($"Created images directory: {imagesDirectory}");
}

// Read the markdown content
string markdownContent = File.ReadAllText(markdownFilePath, System.Text.Encoding.UTF8);

// Process figure tags
var figurePattern = @"<figure>(.*?)</figure>";
var regex = new System.Text.RegularExpressions.Regex(figurePattern, 
    System.Text.RegularExpressions.RegexOptions.Singleline | 
    System.Text.RegularExpressions.RegexOptions.IgnoreCase);

int figureCount = 0;
string processedContent = regex.Replace(markdownContent, match => {
    figureCount++;
    return $"![Figure {figureCount}](images/figure{figureCount}.png)";
});

// Save the processed markdown
File.WriteAllText(processedFilePath, processedContent, System.Text.Encoding.UTF8);

Console.WriteLine($"Processed markdown saved to: processed_{originalFileName}.md");
Console.WriteLine($"Total figures converted: {figureCount}");
Console.WriteLine($"Images should be placed in: {Path.GetRelativePath(outputDirectory, imagesDirectory)}");

#!csharp

using UglyToad.PdfPig;
using UglyToad.PdfPig.Content;
using UglyToad.PdfPig.Graphics.Colors;
using UglyToad.PdfPig.Rendering.Skia;
using SkiaSharp;

var baseImageFileName = Path.Combine(imagesDirectory, Path.GetFileNameWithoutExtension(filePath));

// Only process if the original file is a PDF
if (Path.GetExtension(filePath).ToLowerInvariant() == ".pdf")
{
    using (var document = PdfDocument.Open(filePath))
    {
        document.AddSkiaPageFactory(); // Same as document.AddPageFactory<SKPicture, SkiaPageFactory>()

        // render only pages that have figures
        foreach (var pageNumber in result.Figures.Select(f => f.BoundingRegions[0].PageNumber).Distinct())
        {
            using (var fs = new FileStream($"{baseImageFileName}_{pageNumber}.png", FileMode.Create))
            using (var ms = document.GetPageAsPng(pageNumber, 2, RGBColor.White))
            {
                ms.WriteTo(fs);
            }
        }
    }
    // Console.WriteLine("PDF file detected. Extracting images...");
    
    // // Create images subdirectory if it doesn't exist
    // var imagesDirectory = Path.Combine(outputDirectory, "images");
    // if (!Directory.Exists(imagesDirectory))
    // {
    //     Directory.CreateDirectory(imagesDirectory);
    // }
    
    // // Delete existing images with the same prefix
    // var imagePrefix = $"{originalFileName}_";
    // var existingImages = Directory.GetFiles(imagesDirectory, $"{imagePrefix}*");
    // foreach (var imageFile in existingImages)
    // {
    //     File.Delete(imageFile);
    //     Console.WriteLine($"Deleted existing image: {Path.GetFileName(imageFile)}");
    // }
    
    // // Extract images from PDF
    // using (PdfDocument document = PdfDocument.Open(filePath))
    // {
    //     int imageCount = 0;
        
    //     for (int pageNum = 1; pageNum <= document.NumberOfPages; pageNum++)
    //     {
    //         Page page = document.GetPage(pageNum);
            
    //         foreach (var image in page.GetImages())
    //         {
    //             imageCount++;
    //             try
    //             {
    //                 // Get image bytes
    //                 var imageBytes = image.RawBytes.ToArray();
                    
    //                 // Determine file extension based on image format
    //                 string extension = ".png"; // default
    //                 if (image.ColorSpace?.Name?.Contains("JPEG") == true || 
    //                     image.Filter?.Contains("DCTDecode") == true)
    //                 {
    //                     extension = ".jpg";
    //                 }
                    
    //                 // Save image with proper naming convention
    //                 var imageFileName = $"{originalFileName}_figure{imageCount}{extension}";
    //                 var imageFilePath = Path.Combine(imagesDirectory, imageFileName);
                    
    //                 File.WriteAllBytes(imageFilePath, imageBytes);
    //                 Console.WriteLine($"Extracted image {imageCount}: {imageFileName}");
    //             }
    //             catch (Exception ex)
    //             {
    //                 Console.WriteLine($"Failed to extract image {imageCount}: {ex.Message}");
    //             }
    //         }
    //     }
        
    //     Console.WriteLine($"Total images extracted: {imageCount}");
    // }
}
else
{
    Console.WriteLine($"File is not a PDF ({Path.GetExtension(filePath)}). Skipping image extraction.");
}

#!csharp

using System.Drawing;
// now we can use the fact that we have the bounding boxes of the figures so we can render them
int FigureIndex = 1;
foreach (var figure in result.Figures)
{
    var pageNumber = figure.BoundingRegions[0].PageNumber;
    var imageFileName = $"{baseImageFileName}_{pageNumber}.png";
 
    // Load the full page image
    using (var bitmap = SKBitmap.Decode(imageFileName))
    {
        var boundingRegion = figure.BoundingRegions[0];
        var polygon = boundingRegion.Polygon;

        List<PointF> absolutePoints = new();
        for (int i = 0; i < polygon.Count; i += 2)
        {
            float x = polygon[i] * bitmap.Width;
            float y = (1 - polygon[i + 1]) * bitmap.Height; // Flip Y-axis for top-left origin
            absolutePoints.Add(new PointF(x, y));
        }

        float minX = absolutePoints.Min(p => p.X);
        float maxX = absolutePoints.Max(p => p.X);
        float minY = absolutePoints.Min(p => p.Y);
        float maxY = absolutePoints.Max(p => p.Y);
        float width = maxX - minX;
        float height = maxY - minY;
        float side = Math.Max(width, height); // Square side length

        
        // Extract the figure region
        var rect = new SKRectI((int)minX, (int)minY, (int)(minX + width), (int)(minY + height));
        using (var croppedBitmap = new SKBitmap((int)width, (int) height))
        {
            bitmap.ExtractSubset(croppedBitmap, rect);
            
            // Save the cropped figure
            var figureFileName = baseImageFileName + $"_figure{FigureIndex++}.png";
            //delete existing file if it exists
            if (File.Exists(figureFileName))
            {
                File.Delete(figureFileName);
                Console.WriteLine($"Deleted existing figure file: {figureFileName}");
            }
            using (var image = SKImage.FromBitmap(croppedBitmap))
            using (var data = image.Encode(SKEncodedImageFormat.Png, 100))
            using (var stream = File.OpenWrite(figureFileName))
            {
                data.SaveTo(stream);
            }
            
            Console.WriteLine($"Extracted figure: {figureFileName}");
        }
    }
}
